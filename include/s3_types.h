#ifndef S3_TYPES_H_INCLUDED
#define S3_TYPES_H_INCLUDED

/*
 * s3_types.h
 *
 * Публичные типы данных и callback'и для S3-клиента:
 *  - конфиг среды и клиента (s3_env_config, s3_client_config);
 *  - параметры операций (create bucket, PUT, GET, list, batch delete);
 *  - структуры описания объектов и результатов удаления;
 *  - типы callback'ов для list и batch delete.
 */

#include <stddef.h>     /* size_t */
#include <stdint.h>     /* uint64_t */
#include <sys/types.h>  /* off_t */

#ifdef __cplusplus
extern "C" {
#endif


/* ----------------------------------------------------------------------
 * 1. Create bucket
 * ---------------------------------------------------------------------- */

/**
 * Параметры создания бакета.
 *
 * Большинство полей опциональны — S3/MinIO принимают простейший запрос
 * без дополнительных настроек.
 */
struct s3_create_bucket_params {
    /**
     * ACL для бакета (Access Control List).
     *
     * Примеры (S3-style):
     *  - "private"
     *  - "public-read"
     *  - "public-read-write"
     *
     * Может быть NULL — тогда сервер применит значение по умолчанию.
     */
    const char *acl;

    /**
     * Location constraint / регион бакета.
     *
     * Для AWS S3 это может быть, например, "eu-central-1".
     * Для MinIO обычно можно не задавать (NULL).
     */
    const char *location;
};

/* ----------------------------------------------------------------------
 * 2. PUT / GET (операции над объектами)
 * ---------------------------------------------------------------------- */

/**
 * Параметры PUT-операции (загрузка данных в объект).
 */
struct s3_put_params {
    /**
     * Смещение в источнике данных (fd) в байтах.
     *
     * На первом шаге можно игнорировать и всегда начинать с 0,
     * но поле оставлено на будущее (например, для резюма/частичного PUT).
     */
    off_t offset;

    /**
     * Длина контента в байтах.
     *
     * Обычно обязательна для PUT:
     *  - используется в заголовке Content-Length;
     *  - может быть использована для прогресса/проверок.
     */
    size_t content_length;

    /**
     * MIME-тип загружаемого объекта.
     *
     * Примеры:
     *  - "application/octet-stream"
     *  - "text/plain"
     *  - "image/png"
     *
     * Может быть NULL — тогда библиотека может подставить
     * "application/octet-stream" по умолчанию.
     */
    const char *content_type;
};

/**
 * Параметры GET-операции (скачивание объекта).
 */
struct s3_get_params {
    /**
     * Смещение в объекте (байты), с которого начать чтение.
     *
     * 0 = читать с начала.
     *
     * Может использоваться для Range-запросов и докачки.
     */
    off_t offset;

    /**
     * Максимальное количество байт для чтения.
     *
     * 0 = читать до конца объекта (или до EOF).
     */
    size_t limit;
};

/* ----------------------------------------------------------------------
 * 3. List объектов
 * ---------------------------------------------------------------------- */

/**
 * Описание одного элемента в результатах list.
 *
 * Это может быть либо реальный объект (is_prefix == 0),
 * либо "общий префикс" (псевдодиректория, is_prefix == 1).
 */
struct s3_object_info {
    /**
     * Имя объекта или префикса.
     *
     * Для объекта — полный ключ ("path/to/file.txt").
     * Для префикса — строка, заканчивающаяся delimiter'ом ("path/to/").
     *
     * Важно:
     *  - строка может указывать на временный буфер;
     *  - её нельзя сохранять/использовать после возврата из callback'а,
     *    если документация реализации не обещает обратное.
     */
    const char *key;

    /**
     * Размер объекта в байтах.
     *
     * Для реальных объектов — >= 0.
     * Для "префиксов" (is_prefix == 1) обычно 0.
     */
    uint64_t size;

    /**
     * ETag объекта (обычно MD5-хэш или кавычки с хэшем).
     *
     * Может быть NULL.
     */
    const char *etag;

    /**
     * Время последней модификации объекта.
     *
     * Как правило, строка в ISO8601 / RFC3339 формате:
     *  - "2025-11-19T12:34:56.000Z"
     *
     * Может быть NULL, если сервер не вернул значение.
     */
    const char *last_modified;

    /**
     * 0 = это объект,
     * 1 = это "общий префикс" (dir-like элемент при использовании delimiter).
     */
    int is_prefix;
};

/**
 * Параметры list-операции.
 *
 * Маппятся примерно на параметры S3 ListObjectsV2:
 *  - prefix
 *  - delimiter
 *  - max_keys
 */
struct s3_list_params {
    /**
     * Префикс для фильтрации ключей.
     *
     * Пример: "photos/2023/"
     *
     * Может быть NULL — тогда возвращаются все объекты.
     */
    const char *prefix;

    /**
     * Delimiter для группировки ключей в "префиксы".
     *
     * Чаще всего "/".
     *
     * Если NULL, сервер вернёт "плоский" список ключей.
     */
    const char *delimiter;

    /**
     * Максимальное количество ключей за один HTTP-запрос.
     *
     * Если 0, библиотека может использовать значение по умолчанию
     * (например, 1000).
     *
     * Если всего объектов больше, чем max_keys, библиотека
     * сама будет ходить по continuation token'ам до тех пор,
     * пока callback не попросит остановиться или объекты не закончатся.
     */
    size_t max_keys;

    /**
     * Упрощённый флаг "рекурсивного" листинга.
     *
     *  - 1 = игнорировать delimiter и возвращать полный список,
     *        как будто delimiter = NULL;
     *  - 0 = использовать delimiter как есть.
     */
    int recursive;
};

/**
 * Callback, вызываемый для каждого элемента (объекта или префикса)
 * в результате list-операции.
 *
 * Возвращаемое значение:
 *  - 0  → продолжать листинг;
 *  - !=0 → остановить листинг как можно скорее.
 *
 * Важно:
 *  - реализатор callback'а не должен блокировать tx-тред надолго;
 *  - строки внутри s3_object_info действительны только на время вызова,
 *    если документация реализации не говорит обратное.
 */
typedef int (*s3_list_object_cb)(const struct s3_object_info *info,
                                 void *userdata);

/* ----------------------------------------------------------------------
 * 4. Batch delete
 * ---------------------------------------------------------------------- */

/**
 * Параметры для batch delete.
 */
struct s3_delete_params {
    /**
     * Quiet-флаг (как в Amazon S3).
     *
     * 0 = вернуть подробные результаты по каждому ключу;
     * 1 = режим "тихий" — сервер может не присылать список успешно
     *     удалённых объектов (но ошибки всё равно будут отражены).
     */
    int quiet;
};

/**
 * Результат по одному ключу в batch delete.
 *
 * Маппится примерно на формат DeleteObjectsResult:
 *  - успешные удаления;
 *  - ошибки с кодами/сообщениями.
 */
struct s3_delete_result_entry {
    /**
     * Ключ, который пытались удалить.
     */
    const char *key;

    /**
     * Признак успешного удаления.
     *
     * 1 = объект удалён (или считается удалённым,
     *     если сервер сообщает так в quiet-режиме);
     * 0 = по этому ключу произошла ошибка.
     */
    int success;

    /**
     * Строковый код ошибки от S3/MinIO (если есть).
     *
     * Примеры:
     *  - "AccessDenied"
     *  - "NoSuchKey"
     *
     * Может быть NULL, если success == 1.
     */
    const char *error_code;

    /**
     * Текстовое описание ошибки (если есть).
     *
     * Может быть NULL.
     */
    const char *error_message;
};

/**
 * Callback, вызываемый для результата по каждому ключу
 * в batch delete операции.
 *
 * Возвращаемое значение:
 *  - 0  → продолжать обработку остальных результатов;
 *  - !=0 → остановить передачу результатов как можно скорее
 *          (HTTP-запрос уже завершён, просто библиотека
 *          перестаёт вызывать callback для оставшихся элементов).
 */
typedef int (*s3_delete_result_cb)(const struct s3_delete_result_entry *entry,
                                   void *userdata);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* S3_TYPES_H_INCLUDED */
