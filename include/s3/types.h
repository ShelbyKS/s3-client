#ifndef S3_TYPES_H
#define S3_TYPES_H

#ifdef __cplusplus
extern "C" {
#endif

/*
 *  s3/types.h
 *
 *  Общие типы S3-клиента:
 *    - структуры параметров запросов (GET/PUT);
 *    - информация об объекте (Content-Length, ETag, Content-Type);
 *    - буфер для удобного GET/PUT;
 *    - callback-типы (headers/data/read/done).
 */

#include <stddef.h>  /* size_t */
#include <stdint.h>  /* uint64_t, uint8_t */

/* Вперёд объявляем структуры, чтобы использовать указатели на них. */
struct s3_request;
struct s3_error;

/* ============================================================
 *                         Буфер
 * ========================================================== */

/*
 * Простой буфер для работы "GET в память" / "PUT из памяти".
 *
 * Важно:
 *   - Память для data выделяет пользователь.
 *   - Библиотека НИКОГДА не вызывает realloc/free на этом буфере.
 *   - Для GET:
 *       - size  — ёмкость буфера;
 *       - used  — сколько реально записано байт;
 *       - если данных приходит больше, чем size, запрос завершится с ошибкой.
 *   - Для PUT:
 *       - size  — ёмкость буфера;
 *       - used  — сколько байт из data нужно отправить (обычно == size).
 */
typedef struct s3_buffer {
    uint8_t *data; /* указатель на буфер */
    size_t   size; /* общий размер выделенной памяти */
    size_t   used; /* фактическое количество байт данных */
} s3_buffer_t;

/* ============================================================
 *                  Информация об объекте (GET)
 * ========================================================== */

/*
 * Метаданные объекта, доступные при GET (после получения заголовков).
 *
 * Все строковые поля указывают на внутренние данные библиотеки
 * и действительны только в момент вызова headers_cb.
 */
typedef struct s3_object_info {
    uint64_t    content_length;  /* 0, если неизвестно или chunked */
    const char *etag;            /* может быть NULL */
    const char *content_type;    /* может быть NULL */

    /* Зарезервировано для будущего:
     *   - last_modified;
     *   - user metadata (x-amz-meta-*);
     *   - storage class и т.д.
     */
} s3_object_info_t;

/* ============================================================
 *                  Параметры GET-запроса
 * ========================================================== */

/*
 * Параметры object_get.
 *
 * Все строковые поля должны быть null-terminated.
 * Указатели остаются во владении пользователя и должны жить как минимум
 * до завершения запроса.
 */
typedef struct s3_object_get_params {
    const char *bucket;  /* имя бакета (обязательно) */
    const char *key;     /* ключ объекта (обязательно) */

    /*
     * Range (байтовый диапазон) [range_start, range_end], включительно.
     *
     *  - use_range == 0 => Range не будет установлен;
     *  - use_range != 0 => клиент добавит заголовок "Range: bytes=start-end".
     */
    int      use_range;
    uint64_t range_start;
    uint64_t range_end;

    /*
     * Условные GET по ETag.
     *
     *  - if_match:
     *      добавляет заголовок "If-Match: <etag>";
     *  - if_none_match:
     *      добавляет заголовок "If-None-Match: <etag>";
     *
     * Любое поле может быть NULL — тогда соответствующий заголовок не добавляется.
     */
    const char *if_match;
    const char *if_none_match;

    /*
     * В будущем сюда можно добавить:
     *  - If-Modified-Since;
     *  - If-Unmodified-Since;
     *  - версионирование объектов (versionId) и т.д.
     */
} s3_object_get_params_t;

/* ============================================================
 *                  Параметры PUT-запроса
 * ========================================================== */

/*
 * Параметры object_put.
 *
 * Все строковые поля — null-terminated, во владении пользователя.
 */
typedef struct s3_object_put_params {
    const char *bucket;       /* имя бакета (обязательно) */
    const char *key;          /* ключ объекта (обязательно) */

    /*
     * content_length:
     *   - если известна заранее, указать точное значение;
     *   - если (uint64_t)-1, реализация может использовать chunked encoding
     *     и считать размер по EOF (если это поддерживает бэкенд/политика).
     */
    uint64_t    content_length;

    /*
     * Тип содержимого (Content-Type).
     * Если NULL, библиотека может:
     *   - не указывать Content-Type, либо
     *   - использовать некий дефолт (например, "application/octet-stream").
     */
    const char *content_type;

    /*
     * В будущем сюда можно добавить:
     *   - x-amz-acl;
     *   - x-amz-storage-class;
     *   - x-amz-meta-* (пользовательские метаданные);
     *   - server-side encryption параметры и т.д.
     */
} s3_object_put_params_t;

/* ============================================================
 *                         Callback-и
 * ========================================================== */

/*
 * Callback завершения запроса (GET/PUT).
 *
 *  - req      — запрос, который завершился;
 *  - error    — описание результата:
 *                 * error->code == S3_OK при успехе;
 *                 * любой другой код при ошибке;
 *  - user_data — то же значение, что было передано в s3_object_get/put().
 *
 * Внимание:
 *   - req может быть уничтожен внутри колбэка через s3_request_cancel()
 *     или через s3_client_destroy() (если протокол использования это позволяет);
 *   - реализация клиента должна гарантировать, что done_cb вызывается
 *     один раз для каждого успешно стартовавшего запроса.
 */
typedef void (*s3_request_done_cb)(
    struct s3_request      *req,
    const struct s3_error  *error,
    void                   *user_data);

/*
 * Callback обработки заголовков при GET.
 *
 *  - вызывается после получения HTTP-заголовков, но до передачи тела;
 *  - может не быть вызван в случае ошибки на ранней стадии (например,
 *    DNS-ошибка, невозможность соединения и т.п.).
 *
 * info указывает на структуру, действительную только во время вызова.
 */
typedef void (*s3_object_get_headers_cb)(
    struct s3_request           *req,
    const s3_object_info_t      *info,
    void                        *user_data);

/*
 * Callback получения данных при GET.
 *
 *  - вызывается для каждого куска body;
 *  - data/len действительны только на время вызова (внутренний буфер);
 *  - пользователь должен скопировать данные, если хочет сохранить их.
 *
 * Возвращаемое значение:
 *   - 0  — всё OK, продолжать загрузку;
 *   - !=0 — пользователь просит прервать запрос
 *           (клиент завершит его с ошибкой).
 */
typedef int (*s3_object_get_data_cb)(
    struct s3_request     *req,
    const uint8_t         *data,
    size_t                 len,
    void                  *user_data);

/*
 * Callback чтения данных при PUT.
 *
 *  - req       — текущий запрос;
 *  - buf       — буфер, в который нужно записать очередной блок данных;
 *  - len       — размер доступного буфера;
 *  - out_len   — пользователь должен установить, сколько байт записано;
 *  - eof       — пользователь должен установить в 1, если данные закончились;
 *  - user_data — то же, что передано в s3_object_put().
 *
 * Возвращаемое значение:
 *   - 0  — всё OK, продолжать;
 *   - !=0 — прервать запрос (клиент завершит его с ошибкой).
 *
 * Пример логики:
 *
 *   if (no_more_data) {
 *       *out_len = 0;
 *       *eof = 1;
 *       return 0;
 *   } else {
 *       size_t n = min(len, remaining);
 *       memcpy(buf, src + offset, n);
 *       offset += n;
 *       *out_len = n;
 *       *eof = 0;
 *       return 0;
 *   }
 */
typedef int (*s3_object_put_read_cb)(
    struct s3_request *req,
    uint8_t           *buf,
    size_t             len,
    size_t            *out_len,
    int               *eof,
    void              *user_data);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* S3_TYPES_H */
